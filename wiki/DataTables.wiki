#summary Moriarty DataTables

<wiki:toc max_depth="2" />

= Introduction =

DataTable is Moriarty's implementation of the Active Record pattern for RDF data. Currently this is read only but it does provide a very simple way to create and run SPARQL queries.


= Details =

DataTable (in file datatable.class.php) is the class that constructs the queries. DataTableResult (in datatableresult.class.php) is a class that represents the results of a query. The interface to DataTable takes inspiration from [http://codeigniter.com/user_guide/database/active_record.html CodeIgniter's Active Record] class, adapted slightly for some RDF specifics.

DataTable uses method chaining to make the code more compact and readable. All of the following are equivalent:

{{{
$dt->select('name')->from('person')->limit(5);

$dt->select('name');
$dt->from('person');
$dt->limit(5);

$dt->select('name')->limit(5);
$dt->from('person');
}}}

= !DataTable Methods =

== Constructor ==

The DataTable constructor requires the URI of the Talis Platform store as its first parameter, e.g.:

{{{
$dt = new DataTable('http://api.talis.com/stores/mystore');
}}}

Optionally a Credentials object can be supplied as the second parameter (see credentials.class.php).

*Advanced*: A third, optional, parameter allows an alternate HttpRequestFactory to be specified for when you need an alternate HTTP implementation to the default cURL-based one

== get() ==
Runs the constructed query and returns the results as an instance of DataTableResult

== map($uri_or_array, $short_name) ==
Maps a URI to a short name. The first parameter can either be a URI or an associative array of uri and shortname mappings in which case the second parameter is ignored. 
Short names are used by other methods to refer to property and class URIs. 

The following are equivalent:

{{{
$dt->map('http://xmlns.com/foaf/0.1/name', 'name');
$dt->map('http://xmlns.com/foaf/0.1/nick', 'nick');

$dt->map( array('http://xmlns.com/foaf/0.1/name' => 'name', 'http://xmlns.com/foaf/0.1/nick' => 'nick'));
}}}


== select($field_list) ==
Specifies the variables you want to select in your query. It takes a single parameter which is a comma separated list of field names (which must be mapped short names) or "dotted path names", explained below.

All of the following are valid:
{{{
$dt->select('name');
$dt->select('name,age');
$dt->select(' name  , age');
}}}

The following code will select the foaf:names of every resource in a store:

{{{
$dt = new DataTable('http://api.talis.com/stores/mystore');
$dt->map('http://xmlns.com/foaf/0.1/name', 'name');
$dt->select('name');
$dt->get();
}}}

In addition to mapped field names, DataTable supports an extended syntax for expressing traversal of the relationships in the RDF. Dotted path names are a pair of mapped names delimited by a full stop, e.g. friend.name

Both parts of a dotted path name must be mapped short names. They can be interpreted as a join between resources in the data. friend.name can be translated as "the name of the resource that is the value of the matching result's friend property". In the query resules the dotted path name is referenced by replacing the dot with an underscore, so friend.name becomes a field called friend_name

The following code will select the foaf:names of every resource in a store and the foaf:names of everyone they know:

{{{
$dt = new DataTable('http://api.talis.com/stores/mystore');
$dt->map('http://xmlns.com/foaf/0.1/name', 'name');
$dt->map('http://xmlns.com/foaf/0.1/knows', 'knows');
$dt->select('name,knows.name');
$dt->get();
$res = $dt->get();

foreach ($res->result() as $row) {
   echo $row->name;
   echo $row->knows_name;
}
}}}


== from($type_list) ==
Specifies types of the resources you want to select in your query. It takes a single parameter which is a comma separated list of types (which must be mapped short names). If multiple types are specified then the selected resources must have an rdf:type triple for every one of the types.

All of the following are valid:
{{{
$dt->from('person');
$dt->from('document,book');
}}}

The following code will select the foaf:names of every foaf:Person in a store:

{{{
$dt = new DataTable('http://api.talis.com/stores/mystore');
$dt->map('http://xmlns.com/foaf/0.1/name', 'name');
$dt->map('http://xmlns.com/foaf/0.1/Person', 'person');
$dt->select('name')->from('person');
$dt->get();
}}}

== distinct() ==
Specifies that the query results must be distinct (i.e. without duplicate rows). 

All of the following are valid:
{{{
$dt->from('person');
$dt->from('document,book');
}}}

The following code will select the unique foaf:names of every resource in a store:

{{{
$dt = new DataTable('http://api.talis.com/stores/mystore');
$dt->map('http://xmlns.com/foaf/0.1/name', 'name');
$dt->select('name')->distinct();
$dt->get();
}}}

== limit($value, $offset) ==
Specifies the maximum number of rows to return in the query and, optionally, an offset row number to start from. This could be used to implement a paging scheme. The default offset is zero.

Select the first five names in a store:
{{{
$dt->select('name')->limit(5);
}}}

Select names 15 through to 19 in a store:

{{{
$dt->select('name')->distinct()->limit(5, 15);
}}}

*Note*: Using offset without specifying a sort order may lead to unpredictable results.

== order_by($field, $ordering) ==
Specifies a sort order for the query results. The first parameter is required and specifies the field name to sort by (which must be a mapped short name). The second parameter is optional and specifies the ordering of the results. It must be one of 'asc' (meaning ascending order) or 'desc' (meaning descending order). The default ordering is 'asc'.

Select names and ages in a store and return them in age order
{{{
$dt->select('name,age')->order_by('age');
}}}

Select names in a store and return them in descending order
{{{
$dt->select('name')->order_by('name', 'desc');
}}}

Multiple orderings can be specified by repeating this method call:

Select names and ages in a store and return them in age order. For example to sort by age and then by name descending:
{{{
$dt->select('name,age')->order_by('age')->order_by('name', 'desc');
}}}

== where($field, $value) ==
Specifies a constraint on a literal value. Multiple calls to this method are conjunctive, i.e. all the constraints must apply to the resources.

Select all names where the person has a nickname of santa:

{{{
$dt = new DataTable('http://api.talis.com/stores/mystore');
$dt->map('http://xmlns.com/foaf/0.1/name', 'name');
$dt->map('http://xmlns.com/foaf/0.1/nick', 'nick');

$dt->select('name')->where('nick', 'santa');
}}}

Select all names where the person has a nickname of santa and a shoe size of 9:

{{{
$dt->select('name')->where('nick', 'santa')->where('shoesize', 9);
}}}

The field name can be suffixed by a boolean operator, one of =, >, <, !=, <=, >=

Select names of all resources that are older than 68
{{{
$dt->select('name')->where('age >', 68);
}}}

Select names of all resources that do not have a nickname of santa:
{{{
$dt->select('name')->where('nick !=', 'santa');
}}}

Boolean, floats and integer types are compared as those specific types, not strings:
{{{
$dt->select('name')->where('jolly', TRUE);
$dt->select('name')->where('age >=', 21);
$dt->select('name')->where('shoesize <', 12.76);
}}}

*SPARQL Note:* These constraints are implemented as filters with appropriate casts based on the type of variable supplied for the second parameter.

== where_uri($field, $value) ==
Specifies a constraint on a resource value. Multiple calls to this method are conjunctive, i.e. all the constraints must apply to the resources. The first parameter is required and specifies the field name to test (which must be a mapped short name). The second parameter is also required and specifies a URI against which the field name is tested.

Select names of all resources that have a location of http://sws.geonames.org/6269203/
{{{
$dt->select('name')->where('location', 'http://sws.geonames.org/6269203/');
}}}

*SPARQL Note:* These constraints are implemented as additional graph patterns.


== optional($field_list) ==
Specifies the variables you want to optionally select in your query. It takes a single parameter which is a comma separated list of field names (which must be mapped short names). Optional variables will be returned only if there is matching data for them, otherwise they have a null value. In contrast the select method requires that all results must have values for the fields specified. At least one variable must be specified by select before any optional variables can be used.

Select the names of all the resources in a store and the nicknames of those resources that have them:
{{{
$dt = new DataTable('http://api.talis.com/stores/mystore');
$dt->map('http://xmlns.com/foaf/0.1/name', 'name');
$dt->map('http://xmlns.com/foaf/0.1/nick', 'nick');

$dt->select('name')->optional('nick');
}}}

== get_sparql() ==
Returns the generated SPARQL query

= !DataTableResult Methods =

== num_rows() ==
Returns the number of rows in the result set

== num_fields() ==
Returns the number of fields in the result set

== result() ==
Returns the query result as an array of objects, or an empty array on any failure. Each field in the original query is mapped to an object variable.

For example:
{{{
$dt = new DataTable('http://api.talis.com/stores/mystore');
$dt->map('http://xmlns.com/foaf/0.1/name', 'name');
$dt->map('http://xmlns.com/foaf/0.1/nick', 'nick');

$dt->select('name,nick')->limit(10);
$res = $dt->get();

foreach ($res->result() as $row) {
   echo $row->name;
   echo $row->nick;
}
}}}

== result_array() ==
Returns the query result as an array of associative arrays, or an empty array on any failure. The keys and values of the associative array correspond with the fields and values in the results.

For example:
{{{
$dt->select('name,nick')->limit(10);
$res = $dt->get();

foreach ($res->result() as $row) {
   echo $row['name'];
   echo $row['nick'];
}
}}}

== row($index) ==
Returns a single result row as an object. The $index parameter is optional and defaults to zero.

For example:
{{{
$dt->select('name,nick')->limit(10);
$res = $dt->get();

$row = $res->row(5);
echo $row->name;
echo $row->nick;
}}}

== row_array($index) ==
Returns a single result row as an associative array. The $index parameter is optional and defaults to zero.

For example:
{{{
$dt->select('name,nick')->limit(10);
$res = $dt->get();

$row = $res->row_array();
echo $row['name'];
echo $row['nick'];
}}}

#summary Moriarty DataTables

<wiki:toc max_depth="1" />

= Introduction =

DataTable is Moriarty's implementation of the Active Record pattern for RDF data. Currently this is read only but it does provide a very simple way to create and run SPARQL queries.


= Details =

DataTable (in file datatable.class.php) is the class that constructs the queries. DataTableResult (in datatableresult.class.php) is a class that represents the results of a query. The interface to DataTable takes inspiration from [http://codeigniter.com/user_guide/database/active_record.html CodeIgniter's Active Record] class, adapted slightly for some RDF specifics.

DataTable uses method chaining to make the code more compact and readable. All of the following are equivalent:

{{{
$dt->select('name')->from('person')->limit(5);

$dt->select('name');
$dt->from('person');
$dt->limit(5);

$dt->select('name')->limit(5);
$dt->from('person');
}}}

= !DataTable Methods =

== Constructor ==

The DataTable constructor requires the URI of the Talis Platform store as its first parameter, e.g.:

{{{
$dt = new DataTable('http://api.talis.com/stores/mystore');
}}}

Optionally a Credentials object can be supplied as the second parameter (see credentials.class.php).

*Advanced*: A third, optional, parameter allows an alternate HttpRequestFactory to be specified for when you need an alternate HTTP implementation to the default cURL-based one

== get() ==
Runs the constructed query and returns the results as an instance of DataTableResult

== map($uri_or_array, $short_name) ==
Maps a URI to a short name. The first parameter can either be a URI or an associative array of uri and shortname mappings in which case the second parameter is ignored. 
Short names are used by other methods to refer to property and class URIs. 

The following are equivalent:

{{{
$dt->map('http://xmlns.com/foaf/0.1/name', 'name');
$dt->map('http://xmlns.com/foaf/0.1/nick', 'nick');

$dt->map( array('http://xmlns.com/foaf/0.1/name' => 'name', 'http://xmlns.com/foaf/0.1/nick' => 'nick'));
}}}


== select($field_list) ==
Specifies the variables you want to select in your query. It takes a single parameter which is a comma separated list of field names (which must be mapped short names) or "dotted path names", explained below.

All of the following are valid:
{{{
$dt->select('name');
$dt->select('name,age');
$dt->select(' name  , age');
}}}

The following code will select the foaf:names of every resource in a store:

{{{
$dt = new DataTable('http://api.talis.com/stores/mystore');
$dt->map('http://xmlns.com/foaf/0.1/name', 'name');
$dt->select('name');
$dt->get();
}}}

In addition to mapped field names, DataTable supports an extended syntax for expressing traversal of the relationships in the RDF. Dotted path names are a pair of mapped names delimited by a full stop, e.g. friend.name

Both parts of a dotted path name must be mapped short names. They can be interpreted as a join between resources in the data. friend.name can be translated as "the name of the resource that is the value of the matching result's friend property". In the query resules the dotted path name is referenced by replacing the dot with an underscore, so friend.name becomes a field called friend_name

The following code will select the foaf:names of every resource in a store and the foaf:names of everyone they know:

{{{
$dt = new DataTable('http://api.talis.com/stores/mystore');
$dt->map('http://xmlns.com/foaf/0.1/name', 'name');
$dt->map('http://xmlns.com/foaf/0.1/knows', 'knows');
$dt->select('name,knows.name');
$dt->get();
$res = $dt->get();

foreach ($res->result() as $row) {
   echo $row->name;
   echo $row->knows_name;
}
}}}


== from($type_list) ==
Specifies types of the resources you want to select in your query. It takes a single parameter which is a comma separated list of types (which must be mapped short names). If multiple types are specified then the selected resources must have an rdf:type triple for every one of the types.

All of the following are valid:
{{{
$dt->from('person');
$dt->from('document,book');
}}}

The following code will select the foaf:names of every foaf:Person in a store:

{{{
$dt = new DataTable('http://api.talis.com/stores/mystore');
$dt->map('http://xmlns.com/foaf/0.1/name', 'name');
$dt->map('http://xmlns.com/foaf/0.1/Person', 'person');
$dt->select('name')->from('person');
$dt->get();
}}}

== distinct() ==
Specifies that the query results must be distinct (i.e. without duplicate rows). 

All of the following are valid:
{{{
$dt->from('person');
$dt->from('document,book');
}}}

The following code will select the unique foaf:names of every resource in a store:

{{{
$dt = new DataTable('http://api.talis.com/stores/mystore');
$dt->map('http://xmlns.com/foaf/0.1/name', 'name');
$dt->select('name')->distinct();
$dt->get();
}}}

== limit($value, $offset) ==
Specifies the maximum number of rows to return in the query and, optionally, an offset row number to start from. This could be used to implement a paging scheme. The default offset is zero.

Select the first five names in a store:
{{{
$dt->select('name')->limit(5);
}}}

Select names 15 through to 19 in a store:

{{{
$dt->select('name')->distinct()->limit(5, 15);
}}}

*Note*: Using offset without specifying a sort order may lead to unpredictable results.

== order_by($field, $ordering) ==
Specifies a sort order for the query results. The first parameter is required and specifies the field name to sort by (which must be a mapped short name). The second parameter is optional and specifies the ordering of the results. It must be one of 'asc' (meaning ascending order) or 'desc' (meaning descending order). The default ordering is 'asc'.

Select names and ages in a store and return them in age order
{{{
$dt->select('name,age')->order_by('age');
}}}

Select names in a store and return them in descending order
{{{
$dt->select('name')->order_by('name', 'desc');
}}}

Multiple orderings can be specified by repeating this method call:

Select names and ages in a store and return them in age order. For example to sort by age and then by name descending:
{{{
$dt->select('name,age')->order_by('age')->order_by('name', 'desc');
}}}

== where($field, $value) ==
Specifies a constraint on a literal value. Multiple calls to this method are conjunctive, i.e. all the constraints must apply to the resources.

Select all names where the person has a nickname of santa:

{{{
$dt = new DataTable('http://api.talis.com/stores/mystore');
$dt->map('http://xmlns.com/foaf/0.1/name', 'name');
$dt->map('http://xmlns.com/foaf/0.1/nick', 'nick');

$dt->select('name')->where('nick', 'santa');
}}}

Select all names where the person has a nickname of santa and a shoe size of 9:

{{{
$dt->select('name')->where('nick', 'santa')->where('shoesize', 9);
}}}

The field name can be suffixed by a boolean operator, one of =, >, <, !=, <=, >=

Select names of all resources that are older than 68
{{{
$dt->select('name')->where('age >', 68);
}}}

Select names of all resources that do not have a nickname of santa:
{{{
$dt->select('name')->where('nick !=', 'santa');
}}}

Boolean, floats and integer types are compared as those specific types, not strings:
{{{
$dt->select('name')->where('jolly', TRUE);
$dt->select('name')->where('age >=', 21);
$dt->select('name')->where('shoesize <', 12.76);
}}}

*SPARQL Note:* These constraints are implemented as filters with appropriate casts based on the type of variable supplied for the second parameter.

== where_uri($field, $value) ==
Specifies a constraint on a resource value. Multiple calls to this method are conjunctive, i.e. all the constraints must apply to the resources. The first parameter is required and specifies the field name to test (which must be a mapped short name). The second parameter is also required and specifies a URI against which the field name is tested.

Select names of all resources that have a location of http://sws.geonames.org/6269203/
{{{
$dt->select('name')->where('location', 'http://sws.geonames.org/6269203/');
}}}

*SPARQL Note:* These constraints are implemented as additional graph patterns.


== optional($field_list) ==
Specifies the variables you want to optionally select in your query. It takes a single parameter which is a comma separated list of field names (which must be mapped short names). Optional variables will be returned only if there is matching data for them, otherwise they have a null value. In contrast the select method requires that all results must have values for the fields specified. At least one variable must be specified by select before any optional variables can be used.

Select the names of all the resources in a store and the nicknames of those resources that have them:
{{{
$dt = new DataTable('http://api.talis.com/stores/mystore');
$dt->map('http://xmlns.com/foaf/0.1/name', 'name');
$dt->map('http://xmlns.com/foaf/0.1/nick', 'nick');

$dt->select('name')->optional('nick');
}}}

== get_sparql() ==
Returns the generated SPARQL query

= !DataTableResult Methods =

== num_rows() ==
Returns the number of rows in the result set

== num_fields() ==
Returns the number of fields in the result set

== result() ==
Returns the query result as an array of objects, or an empty array on any failure. Each field in the original query is mapped to an object variable.

For example:
{{{
$dt = new DataTable('http://api.talis.com/stores/mystore');
$dt->map('http://xmlns.com/foaf/0.1/name', 'name');
$dt->map('http://xmlns.com/foaf/0.1/nick', 'nick');

$dt->select('name,nick')->limit(10);
$res = $dt->get();

foreach ($res->result() as $row) {
   echo $row->name;
   echo $row->nick;
}
}}}

== result_array() ==
Returns the query result as an array of associative arrays, or an empty array on any failure. The keys and values of the associative array correspond with the fields and values in the results.

For example:
{{{
$dt->select('name,nick')->limit(10);
$res = $dt->get();

foreach ($res->result() as $row) {
   echo $row['name'];
   echo $row['nick'];
}
}}}

== rowdata($index) ==
Returns an associative array containing metadata about the values in the specified row. The array keys correspond to field names and the values to another associative array containing the metadata for that field's value. The $index parameter is optional and defaults to zero.

The following metadata keys are available:

  * type - the type of the field's value, one of "uri", "bnode" or "literal"
  * datatype - the datatype of a literal value, or none if no datatype was detected
  * lang - the language code of a literal value, or none if no language was detected

For example:
{{{
$dt->select('name,nick')->limit(10);
$res = $dt->get();

$rowdata = $res->rowdata(5);
echo $rowdata['name']['type'];
echo $rowdata['name']['lang'];
echo $rowdata['name']['datatype'];
}}}


== to_string() ==
Returns a tabular string representation of the results.


= Examples =

The following examples are based on the n² blog post [http://blogs.talis.com/n2/archives/818 SPARQLing data.gov.uk: Edubase Data]. You may find it useful to compare the code here with the SPARQL queries in that post. The numbering of the examples correspond to the numbering used in that blog post.

All of these examples use the same set of mappings:
{{{
$mappings = array(
  'http://education.data.gov.uk/def/school/School' => 'school',
  'http://education.data.gov.uk/def/school/establishmentName' => 'name',
  'http://education.data.gov.uk/def/school/districtAdministrative' => 'district',
  'http://education.data.gov.uk/def/school/nurseryProvision' => 'nursery',
  'http://education.data.gov.uk/def/school/statutoryLowAge' => 'lowage',
  'http://education.data.gov.uk/def/school/statutoryHighAge' => 'highage',
  'http://education.data.gov.uk/def/school/schoolCapacity' => 'capacity',
  'http://education.data.gov.uk/def/school/pupilTeacherRatio' => 'ratio',
  'http://education.data.gov.uk/def/school/openDate' => 'date',
  'http://education.data.gov.uk/def/school/easting' => 'easting',
  'http://education.data.gov.uk/def/school/northing' => 'northing',
  'http://education.data.gov.uk/def/school/establishmentStatus' => 'status',
  'http://education.data.gov.uk/def/school/reasonEstablishmentClosed' => 'reason',
  'http://education.data.gov.uk/def/school/address' => 'address',
  'http://education.data.gov.uk/def/school/address1' => 'address1',
  'http://education.data.gov.uk/def/school/address2' => 'address2',
  'http://education.data.gov.uk/def/school/postcode' => 'postcode',
  'http://education.data.gov.uk/def/school/town' => 'town',
  'http://education.data.gov.uk/def/school/parliamentaryConstituency' => 'cons',
  'http://www.w3.org/2000/01/rdf-schema#label' => 'label',
);
}}}

The datatable instance is created like this:

{{{
$dt = new DataTable('http://api.talis.com/stores/govuk-education');
$dt->map($mappings);
}}}


== Example 1 ==
Select the names of schools in the Administrative District of the City of London Ordering results by name of the school
{{{
$dt->select('name')->from('school')->order_by('name');
$dt->where_uri('district', 'http://statistics.data.gov.uk/id/local-authority-district/00AA');
}}}

== Example 2 ==
Which schools in the BANES area have a nursery?

{{{
$dt->select('name')->from('school')->order_by('name');
$dt->where_uri('district', 'http://statistics.data.gov.uk/id/local-authority-district/00HA')->where('nursery', TRUE);
}}}

== Example 3 ==
Select the names and addresses of schools in the Administrative District of the City of London

{{{
$dt->select('name,address.address1,address.address2,address.postcode,address.town')->from('school')->order_by('name');
$dt->where_uri('district', 'http://statistics.data.gov.uk/id/local-authority-district/00AA');
}}}

== Example 4 ==
Select the name, lowest and highest age ranges, capacity and pupil:teacher ratio for all schools in the Bath & North East Somerset district

{{{
$dt->select('name')->from('school')->order_by('name');
$dt->where_uri('district', 'http://statistics.data.gov.uk/id/local-authority-district/00HA');
$dt->optional('lowage');
$dt->optional('highage');
$dt->optional('capacity');
$dt->optional('ratio');
}}}


== Example 5 ==
What is the uri, name, and opening date of the oldest school in the UK?

{{{
$dt->select('name,date')->from('school')->order_by('date')->limit(1);
}}}

== Example 6 ==
Select the name, easting and northing for the 100 newest schools in the UK

{{{
$dt->select('name,date')->from('school')->order_by('date','desc')->limit(100);
$dt->optional('easting');
$dt->optional('northing');
}}}

== Example 8 ==
Select the uri, name, and the reason for closing for all schools that are currently scheduled for closure.

{{{
$dt->select('name,reason')->from('school');
$dt->where_uri('status','http://education.data.gov.uk/def/school/EstablishmentStatus_Open_but_proposed_to_close');
}}}

== Example 9 ==
In which parliamentary constituencies did schools close in 2008?

{{{
$dt->select('cons,label,cons.label')->from('school')->where_uri('status','http://education.data.gov.uk/def/school/EstablishmentStatus_Closed')->order_by('cons');
$dt->where('date >', '2008-01-01');
$dt->where('date <', '2009-01-01');
}}}